---
title: Gist：记录每日心得
author: yuyao
date: 2024-03-27 14:13:40 +0800
categories: [Trends, exp]
tags: [gist]
pin: true
---

## Useful Links Daily Update

**24/5/22**

[比起 Chrome 浏览器，你可能更需要这份 Firefox「隐私指南」](https://36kr.com/p/2020764433387780)

![pcie](https://raw.githubusercontent.com/yuy4o/yuy4o/main/figures/240522gnu.jpg)

[零一万物模型折腾笔记：官方 Yi-34B 模型基础使用](https://zhuanlan.zhihu.com/p/671387298)

[Qwen1.5 Doc](https://qwen.readthedocs.io/)

**24/5/29**

[大模型中的Top-k、Top-p、Temperature详细含义及解释](https://www.wehelpwin.com/article/4067)

**24/6/5**

[小白如何设置openai api key的环境变量](https://www.cnblogs.com/rmticocean/articles/17999891)

[检索增强生成（RAG）：从理论到 LangChain 实践](https://baoyu.io/translations/rag/retrieval-augmented-generation-rag-from-theory-to-langchain-implementation)

[Weaviate](https://towardsdatascience.com/getting-started-with-weaviate-a-beginners-guide-to-search-with-vector-databases-14bbb9285839)

**24/6/12**

[KAN: Kolmogorov–Arnold Networks](https://arxiv.org/pdf/2404.19756)

[英伟达显卡大解析](https://cloud.tencent.com/developer/article/2384672)

**24/6/17**

[RLHF](https://huggingface.co/blog/rlhf)

[RLOO](https://huggingface.co/blog/putting_rl_back_in_rlhf_with_rloo)，[paper](https://arxiv.org/pdf/2402.14740v1)

[Unlocking Longer Generation with Key-Value Cache Quantization](https://huggingface.co/blog/kv-cache-quantization)

[SD3](https://huggingface.co/blog/zh/sd3)，[paper](https://stability.ai/news/stable-diffusion-3-research-paper)

[Quanto](https://huggingface.co/blog/zh/quanto-introduction)

[unified lora training script-sdxl](https://huggingface.co/blog/zh/sdxl_lora_advanced_script)

[Agents 1.0](https://huggingface.co/blog/zh/open-source-llms-as-agents)，[Transformers Agents 2.0](https://huggingface.co/blog/agents)，[Agent Survey](https://arxiv.org/pdf/2309.07864)，[Agents and tools](https://huggingface.co/docs/transformers/v4.41.3/agents)，[LLM Powered Autonomous Agents](https://lilianweng.github.io/posts/2023-06-23-agent/)

[Synthetic data](https://huggingface.co/blog/synthetic-data-save-costs) [code repo](https://github.com/MoritzLaurer/synthetic-data-blog)

**24/6/19**

[What is GGUF and GGML?](https://medium.com/@phillipgimmi/what-is-gguf-and-ggml-e364834d241c)

**24/6/20**

[安全左移理念，腾讯DevSecOps如何实践？](https://security.tencent.com/index.php/blog/msg/191)

过拟合的原因：1.数据中存在噪声 2.模型复杂数据简单

[为什么需要正则化](https://blog.csdn.net/Apol1o_/article/details/108908147)

[为什么正则化/ 增加惩罚项能减轻过拟合](https://blog.csdn.net/PanYHHH/article/details/107180364)

OpenAI在2020年提出的缩放定律（Scaling Law）指出，模型的最终性能主要与计算量，模型参数量和数据大小三者相关，而与模型的具体结构（层数/深度/宽度）基本无关。而大模型相比于之前的小参数量语言模型，在以上三个方面都做了巨大提升，并显现出一些涌现能力（世界知识，指令遵循，逐步推理等）

通过增量预训练（Continuous Pre-train，CPT）等技术为大模型注入安全行业知识，就成为了安全行业大模型应用的必要手段。缺少这个步骤直接对后续安全任务做监督微调（Supervised Fine-tuning，SFT），大模型则或多或少会面临知识匮乏的问题，随即出现“幻觉”现象，对不懂的问题做出一本正经的回答

**24/6/24**

[GGUF模型文件命名](https://blog.csdn.net/weixin_38650077/article/details/137701554)

**24/6/25**

[利用ollama和open-webui玩转开源大模型](https://wnote.com/post/ai-ollama-open-webui/)，[ollama-docker](https://github.com/valiantlynx/ollama-docker)

[comfyui_colab](https://github.com/comfyanonymous/ComfyUI/blob/master/notebooks/comfyui_colab.ipynb)

[认识Base64，看这篇足够了](https://blog.csdn.net/qq_38157825/article/details/124251372)

**24/6/26**

[RAG框架，都在这了](https://blog.csdn.net/python12345_/article/details/139494454)

[检索增强生成（RAG）：从理论到LangChain实践](https://baoyu.io/translations/rag/retrieval-augmented-generation-rag-from-theory-to-langchain-implementation)

[rag-带你认识了解并劝退](https://wiki.eryajf.net/pages/75e1bc/)

**24/6/29**

[VSCode升级18.6后提示“你已连接到不受Visual Studio Code支持的OS版本](http://www.fenzhengrou.wang/posts/vscode%E5%8D%87%E7%BA%A71.86%E5%90%8E%E6%8F%90%E7%A4%BA%E4%BD%A0%E5%B7%B2%E8%BF%9E%E6%8E%A5%E5%88%B0%E4%B8%8D%E5%8F%97visual-studio-code%E6%94%AF%E6%8C%81%E7%9A%84os%E7%89%88%E6%9C%AC/)

**24/6/30**

[常用聚类算法](https://zhuanlan.zhihu.com/p/104355127)

**24/7/1**

[linux查看防火墙开放端口如何操作](https://www.cnblogs.com/agang-php/p/16459683.html)

[devcontainer.json 的作用](https://learnku.com/docs/learn-docker-together/1/devcontainerjson/13228#7ef2ca)

**24/7/11**

[RAG框架，都在这了!](https://blog.csdn.net/python12345_/article/details/139494454)

**24/8/8**

[【ACL 2023】面向轻量化文图检索的Dual-Encoder模型蒸馏算法ConaCLIP ](https://juejin.cn/post/7254200330492657719)

[刘知远：大模型值得探索的十个研究方向](https://mp.weixin.qq.com/s?__biz=MzAxMzA2MDYxMw==&mid=2651629371&idx=1&sn=8a6a659a220886c5e2f2d5f7947b02c2&chksm=80505851b727d147a761fbc379c418bc043e7fe4b97abdea8534866a38a8444deeb55e2fd838&scene=27)

[刘知远团队大模型技术与交叉应用-汇总](https://blog.csdn.net/zhangyifeng_1995/article/details/135582758)

[OpenBMB](https://github.com/OpenBMB)

[OpenRL](https://openrl-docs.readthedocs.io/zh/latest/)

**24/8/18**

[使用 ZeroTier 和 Parsec 远程桌面办公](https://www.oxcat.com/article-77.html)

[【Parsec + ZeroTier】校园网内免费远程桌面（支持游戏）](https://blog.csdn.net/BlueBlueSkyZ/article/details/123947356)

**24/8/20**

[win10远程桌面连接详细步骤](https://blog.csdn.net/qq_44665283/article/details/122716174)

[OpenCV分享：计算机视觉的六大问题、原因以及解决方案](https://new.qq.com/rain/a/20240314A095EQ00)

**24/9/20**

[浏览器F12（开发者调试工具） 功能介绍](https://cloud.tencent.com/developer/article/1872933)

[top_k与top_p](https://blog.csdn.net/qq_18555105/article/details/130355217)

[LCD液晶显示屏和OLED屏幕哪个好](https://www.sohu.com/a/803027952_121206964)，[OLED AMOLED LCD的优缺点](https://www.quanchu.com.cn/zh-cn/media-center/hykxcn/qchyxw102805.html)，[买显示器分不清LED、OLED 、TN、 VA、IPS](https://www.bilibili.com/read/cv7704611/)

IPS（In-Plane Switching）是一种 LCD（液晶显示屏，Liquid Crystal Display） 的技术。主要用于在颜色表现和视角方面改进传统 LCD 显示器的一些缺点。

1. LCD 是一种基于液晶材料的显示技术。液晶本身不能发光，它通过背光源照射，并通过调整每个像素中液晶分子的排列来控制光线的通过，从而显示出图像。LCD 显示器的主要特点包括：需要背光源（通常是 LED）、能耗较低、对比度、黑色显示效果相对较差（尤其在黑暗环境下）

2. IPS 是 LCD 面板中的一种技术，用于改进传统 TN（Twisted Nematic）面板的不足。它通过改变液晶分子平行排列的方式，改进了视角和颜色表现：
    更广的视角：在 IPS 屏幕上，从不同角度看屏幕时，颜色不会明显失真。
   
    更好的色彩表现：IPS 屏幕能够显示更准确的颜色，非常适合需要精确颜色的工作，如图像处理或设计。

    更慢的响应时间：与 TN 面板相比，响应时间可能稍慢，但现代 IPS 屏幕通过技术进步，已经大大减少了这个差距。

3. OLED（有机发光二极管，Organic Light Emitting Diode）与 LCD 完全不同的一种显示技术。它不需要背光源，因为每个像素都可以自发光，具有以下特点：

    更高对比度：OLED 屏幕能够显示纯黑色，因为关闭像素即可达到完全黑色的效果。

    更薄和柔性：由于不需要背光，OLED 屏幕可以做得非常薄，并可以实现弯曲、折叠等形态。
    
    更高能效：当显示黑色时，OLED 屏幕不发光，节省了能耗。
    
    响应时间快：OLED 显示器的响应速度比 LCD 快得多，非常适合高速变化的图像显示，如游戏和视频。

4. IPS 与 LCD、OLED 的关系：

    IPS 是 LCD 面板中的一种技术改进，主要提升了视角和颜色表现。

    LCD 和 OLED 是两种不同的显示技术。LCD 依赖于背光，OLED 则是自发光技术。

    IPS 属于 LCD 技术，LCD 和 OLED 则是两大不同的显示技术分类。

## 23/08/11

**重构**：强调在保持功能不变的情况下，对代码进行结构调整和优化，以使代码更加清晰、高效和易于维护。通过消除重复代码、改进命名、提取函数、优化数据结构、简化逻辑等，以减少代码的复杂性和提高代码质量

```cpp
#include <iostream>

struct Happy{
  int plus(int a, int b); //3.声明2中定义的成员函数
} happy; //1.定义结构体Happy同时实例化happy, 结构体/类的大括号后加;可看作声明，函数不加;

int Happy::plus(int a, int b){ //2.定义结构体的成员函数plus用作用域解析操作符::
  return a+b;
}

int main()
{
  std::cout << happy.plus(2, 3) << std::endl; //4.初始化实例调用的成员函数
}
```

类 vs 结构体：
1.不指定时类默认成员私有，结构体默认成员公有，两者都可指定公私有
2.类适合创建复杂的、有成员函数和继承关系的数据类型，结构体也可以继承；结构体适合创建简单的、用于存储数据的数据类型，结构体成员定义+声明一般放结构体内

## 23/08/14

struct中有定义的构造函数不能定义时实例化 `struct Listnode{...} listnode`

```cpp
struct Listnode{
  int val;
  Listnode* next;
  // Listnode(int x): val(x), next(nullptr){}
} listnode;
```

## 23/11/19
片段一
```cpp
#include <bits/stdc++.h>
int main(){
    // int a=1, b=2; 正确 for(int a=1, b=2;;)里面一样可以用

    // int a= b=2; 错误 b未声明

    // int b;
    // int a = b = 2; 声明后可连续赋值
    std::cout << b << '\n';
}
```

片段二
```cpp
#include <bits/stdc++.h>
int main(){
    int array[10] = {0}; // array 声明不初始化 内部是随机值
    for (int i : array) std::cout << i;

    std::vector<int> vec(10); // vector 声明不初始化 内部默认0 等价于std::vector<int> vec(10, 0);
    for (int i : vec) std::cout << i << '\n';
}
```

片段三
```cpp
#include <bits/stdc++.h>
int main(){
	int i = 10;
	printf("%d %d %d %d %d", i--, --i, ++i, i++, i);//11 10 10 10 10
	// 10 ++i  11 --i 10  i 10 i-- 10 i++ 9
	// 10 ++i  11 --i 10  i-- 10 i++ 9 i 10 
}
```

片段四

printf === print formatted 格式化输出
- %c：格式化输出字符
- %s：格式化输出字符串
- %f：格式化输出浮点数
- %e 或 %E：格式化输出科学计数法表示的浮点数
- %o：格式化输出八进制整数
- %d：格式化输出十进制整数
- %x 或 %X：格式化输出十六进制整数
- %u：格式化输出无符号整数
- %lld 或 %llu：格式化输出长长整数（long long int）或无符号长长整数（unsigned long long int）
- %p：格式化输出指针的地址

```cpp
#include <stdio.h>
int main() {
    // 二进制0b 八进制0 十六进制0x
    int bin = 0b1101; // 13 = 1*8+ 1*4+0*2+ 1*1
    printf("The dec number is: %d\n", bin);//13

    int oct = 052; // 42 = 5*8+ 2*1
    printf("The dec number is: %d\n", oct);//42

    // 十六进制数字0-9 A B C D E F
    int hex = 0xe; // 14 = 0*16+ 14*1
    printf("The dec number is: %d\n", hex);//14

    return 0;
}
```

片段五
```cpp
// 初始化如果用逗号会共用初始化类型。分号转逗号时避免初始化
ListNode* dummyhead = new ListNode(0); dummyhead->next = head;
```

片段六
```cpp
#include <iostream>
int main(){
    int a = 10, cnt =3;
    while(cnt--){
        // 循环的每次迭代都会创建一个新的局部变量 a，并在迭代结束后被销毁
        // 在循环内部创建的局部变量会遮蔽（隐藏）外部具有相同名称的变量。
        // 这意味着在循环内部，访问 a 时，将访问到的是局部变量 a，而不是外部的全局变量 a
        int a = 5;
        std::cout << "local a =" << a << '\n';
    }
    // 循环内部变量a 在循环结束后不会影响全局变量a
    std::cout << "global a =" << a << '\n';
}
```

## 23/11/25
片段一

windows电脑添加其他用户组 `win+run netplwiz`

片段二

只编译不链接  生成main.o	`g++ main.cpp -c ` 

将编译的结果链接生成可执行文件a.out	`g++ main.o`

片段三

外网连接，主要是三点，第一点是确认自己的网络是公网IP，第二点，确认宽带是光猫拨号还是路由拨号，如果是光猫拨号，打电话给运营商，让运行商改成桥接模式，自己在路由器ppoe拨号上网，第三点，就是在路由器进行端口转发，转发端口为3389，TCP。然后在远程桌面里，进行远程控制时，输入自己的公网ip,不过要注意的是，公网IP，会变，不是固定的。如果你有一个域名，可以用域名做一个ddns，这样就算你的ip变了，也会反馈给域名，可以直接属于域名就行远程桌面控制。

IPv4的IP地址范围是从1.0.0.0到223.255.255.255，
私有IP地址范围包括以下三个段：

- 10.0.0.0 到 10.255.255.255
- 172.16.0.0 到 172.31.255.255
- 192.168.0.0 到 192.168.255.255

此外的属于公有IP地址

## 23/11/28
片段一

NAS→下一步就是UPS然后软路由→AC+AP→服务器→全屋万兆→光纤组网→机房服务器

这个描述是一种技术和设备架构的发展路径，其中包括以下内容：

1. NAS（网络附加存储）：NAS是一种网络设备，用于存储和共享文件。它通常连接到家庭网络，并通过网络协议提供文件访问服务，使多台计算机可以共享和备份文件。

2. UPS（不间断电源）：UPS是一种设备，用于提供电力备份和保护。它可以在停电或电力波动时为设备提供稳定的电力供应，以防止数据丢失或硬件损坏。

3. 软路由：软路由是一种使用软件实现的路由器功能的解决方案。相比传统的硬件路由器，软路由可以在通用计算机上运行，提供更大的灵活性和可配置性。

4. AC+AP：AC代表无线接入控制器（Access Controller），AP代表无线接入点（Access Point）。AC+AP组合用于构建无线局域网（WLAN），AC控制和管理多个AP，提供无线网络的连接和控制。

5. 服务器：服务器是一种计算设备，用于存储、处理和提供数据和服务。在这个上下文中，服务器可能是指用于托管网站、应用程序或其他网络服务的计算机。

6. 全屋万兆：全屋万兆指的是在整个家庭网络中使用10Gbps（即万兆）的以太网连接，以实现更高的数据传输速度和网络性能。

7. 光纤组网：光纤组网是一种使用光纤作为传输介质构建局域网或广域网的技术。光纤具有高带宽和低损耗的特点，适用于长距离和高速数据传输。

8. 机房服务器：机房服务器是指托管在专门的机房或数据中心中的服务器。这些机房通常提供良好的网络连通性、电力供应和物理安全等条件。

综上所述，这个描述表达了一种技术和设备架构的发展路径，从家庭网络存储开始，通过逐步引入UPS、软路由、无线接入控制器和接入点，以及服务器，最终实现全屋万兆和光纤组网，并将服务器托管在机房中。这个过程旨在提供更高速、更稳定的网络连接和数据存储能力。

片段二

**问：clang属于llvm的一部分吗**

答：是的，Clang 是 LLVM 项目的一部分。Clang 是 LLVM 的编译器前端，负责将源代码翻译成中间表示（LLVM IR）。它被设计成高度可扩展、模块化和可重用的工具集合。

LLVM 项目由多个组件组成，其中包括 Clang、LLVM Core、LLDB、LLVM IR 等。Clang 作为 LLVM 的前端之一，负责处理源代码级别的任务，如词法分析、语法分析、语义分析和代码生成。它支持多种编程语言，如 C、C++、Objective-C 和 Swift，并提供了丰富的编译器功能和优化选项。

因此，Clang 是 LLVM 项目中负责编译器前端的组件，与 LLVM Core、LLDB 等其他组件一起构成了 LLVM 的完整编译器基础设施。

**问：lldb是什么**

答：LLDB（Low-Level Debugger）是一款开源的调试器，最初由苹果公司开发并用于调试 macOS 和 iOS 系统上的应用程序。它是一种功能强大的调试工具，可用于分析和调试各种编程语言编写的应用程序，包括 C、C++、Objective-C 和 Swift。

LLDB 提供了一组命令行工具和调试器引擎，用于执行源代码级别的调试操作。它具有一系列功能，包括断点设置、变量查看和修改、堆栈跟踪、表达式求值等。LLDB 还支持多种调试技术，如单步执行、条件断点、内存检测、线程调试等。它还提供了与其他工具和环境的集成能力，如编辑器、集成开发环境（IDE）和脚本。

LLDB 的设计目标是提供高性能的调试体验，并且具有可扩展性和可定制性。它支持多种平台，包括 macOS、iOS、Linux 和 FreeBSD。LLDB 作为一个开源项目，拥有活跃的社区支持和持续的开发，因此在不同的开发环境和项目中广泛使用。

总结来说，LLDB 是一款跨平台的调试器，用于分析和调试各种编程语言编写的应用程序。它提供了一系列功能和命令行工具，可用于执行源代码级别的调试操作，并具有高性能、可扩展性和可定制性的特点。

**问：lldb和llvm什么关系**

答：LLDB 和 LLVM 是两个密切相关的项目，它们都是由 LLVM 社区开发和维护的。

1. LLVM：LLVM（低级虚拟机）是一个开源的编译器基础设施项目，它提供了一组模块化和可重用的编译器工具。LLVM 的核心是一个编译器前端和后端，前端负责将源代码转换为中间表示（LLVM IR），后端负责将中间表示转换为特定目标的机器代码。LLVM 还提供了许多其他工具和库，如优化器、静态分析器和调试器支持等。

2. LLDB：LLDB 是 LLVM 社区开发的调试器工具，用于调试 C、C++、Objective-C 和 Swift 程序。它是 LLVM 项目的一部分，使用 LLVM 的编译器前端（Clang）和调试器引擎，提供了强大的调试功能。LLDB 支持多种平台，包括 macOS、iOS、Linux 和 FreeBSD。它具有命令行界面和可与多个编辑器和集成开发环境（IDE）集成的功能。

LLDB 利用 LLVM 的编译器前端（Clang）来解析和理解源代码，并使用 LLVM 的调试器引擎来执行调试操作。LLDB 可以与 LLVM 的其他工具和库紧密配合，如使用 LLVM 的优化器进行代码优化，或使用 LLVM 的静态分析器进行代码分析。

综上所述，LLDB 是 LLVM 项目的一部分，利用 LLVM 的编译器前端和调试器引擎来提供强大的调试功能。LLVM 提供了 LLDB 所需的基础设施和工具，使其能够进行源代码解析、调试操作和与其他 LLVM 工具的集成。

**问：clang和clangd什么区别**

答：Clang 和 Clangd 是与 C、C++ 和其他编程语言相关的两个不同的工具。

1. Clang：Clang 是一个开源的 C、C++ 和 Objective-C 编译器前端。它被设计成高度可扩展、模块化和可重用的工具集合。Clang 提供了编译、静态分析和代码检查等功能。作为编译器前端，Clang 负责将源代码翻译成中间表示（LLVM IR），然后可以通过 LLVM 后端生成机器代码或执行其他操作。

Clang 提供了许多优点，如快速编译速度、良好的错误和警告信息、模块化的设计以及对最新 C++ 标准的支持。它在许多开发环境和工具链中被广泛使用，并被视为替代传统的 GCC 编译器的一种选择。

2. Clangd：Clangd 是 Clang 的 Language Server Protocol（LSP）实现。LSP 是一种用于提供编辑器和语言服务之间通信的协议。Clangd 作为 LSP 的实现，提供了与 Clang 相关的代码补全、语法检查、重构操作和代码导航等功能。

Clangd 可以与各种编辑器和集成开发环境（IDE）进行集成，使它们能够利用 Clang 的强大功能来提供更好的代码编辑和开发体验。通过 Clangd，编辑器可以与 Clang 进行交互，并利用 Clang 的编译器前端来处理代码的静态分析、语义解析和错误检查等任务。

总结来说，Clang 是一个开源的 C、C++ 和 Objective-C 编译器前端，负责将源代码翻译成中间表示。而 Clangd 是 Clang 的 Language Server Protocol（LSP）实现，允许编辑器和集成开发环境与 Clang 进行通信，以提供更好的代码编辑和开发功能。

**LLVM 项目由多个组件组成，其中包括 Clang、LLVM Core、LLDB、LLVM IR 等。LLVM 的核心是一个编译器前端和后端，Clang（前端）负责将源代码转换为中间表示（LLVM IR），后端负责将中间表示转换为特定目标的机器代码。**

**Clang类似GCC，LLDB类似GDB。Clang是编译器前端，Clangd属于集成到IDE中的语言服务协议LSP**

片段三

jupyuter 幻灯片转html	`jupyter nbconvert 你的文件名称.ipynb --to slides --post serve`

## 23/11/29
片段一

**问：逻辑回归，softmax回归 ，多层感知机 三个什么关系**

答：逻辑回归、Softmax回归和多层感知机（Multilayer Perceptron，MLP）是机器学习和深度学习中常用的模型。

1. 逻辑回归（Logistic Regression）是一种二分类模型，常用于解决二分类问题。它通过对输入特征进行线性组合，并将结果通过一个逻辑函数（如Sigmoid函数）转换为概率值，表示样本属于某个类别的概率。逻辑回归可以看作一个单层的神经网络，其中没有隐藏层，只有输出层。

2. Softmax回归（Softmax Regression）是逻辑回归的扩展，用于解决多分类问题。它通过对输入特征进行线性组合，并将结果通过Softmax函数转换为每个类别的概率分布。Softmax回归可以看作一个单层的神经网络，其中没有隐藏层，只有输出层。

3. 多层感知机（Multilayer Perceptron，MLP）是一种基于人工神经网络的深度学习模型。它由多个神经网络层组成，包括输入层、隐藏层和输出层。隐藏层可以有多个，并且每个隐藏层通常包含多个神经元。每个神经元通过激活函数对输入进行非线性变换，并通过权重连接与下一层的神经元进行信息传递。多层感知机可以用于解决分类和回归问题，并且在深度学习中扮演着重要的角色。

因此，逻辑回归和Softmax回归可以看作是多层感知机的特例，其中多层感知机没有隐藏层，只有输出层。多层感知机是一种更加通用和灵活的模型，可以包含多个隐藏层，从而提供更强大的表达能力和学习能力。

片段二

**问：解释持续集成**

答：持续集成（Continuous Integration，CI）是一种软件开发实践，旨在通过频繁地集成、构建和测试代码，以确保团队成员的代码更容易集成在一起并保持高质量。其核心思想是将代码的集成过程自动化，并尽早地发现和解决集成引入的问题。

在传统的软件开发中，开发人员通常会在开发完一段代码后，手动将代码与主干分支进行集成。这种方式可能导致集成过程中发生冲突、引入错误或者导致整体代码质量下降。而持续集成的目标是通过自动化的集成流程，尽早地发现和解决这些问题。

在持续集成中，开发人员会将代码推送到共享代码仓库，然后由一个持续集成服务器（如Jenkins、Travis CI、GitHub Actions等）自动触发构建和测试过程。这些过程可以包括以下几个步骤：

1. **代码集成**：开发人员将自己的代码与主干分支进行合并，确保代码库中的最新变更被整合到一起。

2. **自动构建**：持续集成服务器会自动获取最新的代码，并进行编译、构建等操作，生成可执行的软件包或者部署所需的文件。

3. **自动化测试**：在构建完成后，持续集成服务器会运行各种类型的自动化测试，如单元测试、集成测试、端到端测试等，以验证代码的正确性和功能性。

4. **质量检查**：持续集成过程还可以包括对代码进行静态代码分析、代码风格检查、代码覆盖率检查等质量检查，以提高代码的质量和可维护性。

5. **报告输出**：持续集成服务器会生成构建和测试的报告，包括构建状态、测试结果、代码覆盖率等信息，以便开发人员及时获取反馈并进行必要的调整。

通过持续集成，团队可以更快地发现潜在的问题，减少集成导致的错误，提高代码质量，并使团队成员能够更加频繁地交付软件。此外，持续集成也为持续交付（Continuous Delivery）和持续部署（Continuous Deployment）提供了基础，以实现自动化的软件交付和部署流程。

总结来说，持续集成是一种通过自动化集成、构建和测试代码的实践，旨在提高团队协作效率、减少集成问题，并确保代码的高质量和可靠性。

片段三

**下载 Visual Studio Code 时不同安装版本的区别：**

- User Installer ：用户安装版，默认安装到用户所在的文件夹下

- System Installers：系统安装版，默认安装路径 C:\Program Files\Microsoft VS Code

- .zip：压缩包版，解压安装

- CLI：控制台安装版

片段四

Electron（原名为Atom Shell）是GitHub开发的一个开源框架。它通过使用Node.js（作为后端）和Chromium的渲染引擎（作为前端）完成跨平台的桌面GUI应用程序的开发。Electron现已被多个开源Web应用程序用于前端与后端的开发，著名项目包括GitHub的Atom和微软的Visual Studio Code。

一个基础的Electron包含三个文件：package.json（元数据）、main.js（代码）和index.html（图形用户界面）。框架由Electron可执行文件（Windows中为electron.exe、macOS中为electron.app、Linux中为electron）提供。开发者可以自行添加标志、自定义图标、重命名或编辑Electron可执行文件。

**问：electron框架和atom编辑器的关系**

答：Electron框架和Atom编辑器之间有着密切的关系。事实上，Atom编辑器是基于Electron框架构建的。

Electron是一个开源的框架，用于构建跨平台的桌面应用程序。它结合了Chromium渲染引擎和Node.js运行时环境，使开发者可以使用Web技术（HTML、CSS和JavaScript）来构建桌面应用。Electron最初由GitHub开发，并在2013年以Atom Shell的名字发布。后来，它改名为Electron，并成为一个独立的开源项目。

Atom编辑器是GitHub开发的一款先进的、可定制的文本编辑器。它具有丰富的功能和插件生态系统，让开发者可以根据自己的需求进行扩展和定制。Atom编辑器最初是使用JavaScript、CoffeeScript和Less等Web技术构建的，它的界面和功能都是通过Web技术实现的，这使得Atom成为了一个高度可定制和可扩展的编辑器。

在Atom的早期版本中，它使用了一种名为Atom Shell的自定义框架来实现跨平台的能力。然而，随着Electron框架的发布，Atom编辑器从0.190版本开始采用了Electron作为其基础框架。这意味着Atom编辑器现在使用Electron框架提供跨平台支持，并且可以利用Electron的强大功能和生态系统来构建和定制编辑器。

因此，可以说Electron框架是Atom编辑器的核心技术，并为Atom的跨平台能力和扩展性提供了支持。同时，由于Electron的开放性和灵活性，它也被许多其他知名应用程序（如Visual Studio Code、Slack和GitHub Desktop等）所采用和使用。

**问：electron和npm什么关系**

答：Electron和npm是两个在前端开发中常用的工具，它们之间具有以下关系：

1. **Electron是一个框架**：Electron是一个开源的框架，用于构建跨平台的桌面应用程序。它结合了Chromium渲染引擎和Node.js运行时环境，使开发者可以使用Web技术（HTML、CSS和JavaScript）来构建桌面应用。Electron提供了丰富的API和功能，使开发者能够访问底层操作系统的功能，并以原生应用的方式运行。

2. **npm是包管理工具**：npm（Node Package Manager）是Node.js的包管理工具，用于管理JavaScript代码包的安装、发布和依赖关系。npm允许开发者在项目中引入第三方的JavaScript库、工具和模块，以便在开发过程中重复使用现有的代码。开发者可以通过npm命令行工具来搜索、安装、更新和卸载包，同时还可以发布自己的包供他人使用。

3. **Electron使用npm**：在Electron开发中，开发者可以使用npm来管理项目的依赖关系和构建过程。通过npm，开发者可以轻松地引入和管理Electron所需的第三方模块和库，如界面组件库、网络请求库、数据库驱动等。通过在项目的package.json文件中定义依赖项，开发者可以确保项目的依赖关系得到正确安装和更新。

4. **Electron应用是Node.js应用**：由于Electron基于Node.js运行时环境，因此Electron应用实际上是Node.js应用。这意味着Electron应用可以使用Node.js的模块系统和npm生态系统中的丰富资源。开发者可以使用npm安装和管理Electron应用的依赖项，并在应用中使用Node.js模块和npm包。

综上所述，Electron和npm之间的关系是，Electron是一个用于构建跨平台桌面应用程序的框架，而npm是Node.js的包管理工具，用于管理JavaScript代码包的安装和依赖关系。在Electron开发中，npm被用于管理项目的依赖项，并提供了方便的方式来引入和管理Electron所需的第三方模块和库。

**问：VScode是electron框架吗**

答：是的，Visual Studio Code (VS Code) 也是使用 Electron 框架构建的。

VS Code 是由 Microsoft 开发的一款轻量级、高度可定制的代码编辑器。它支持多种编程语言，并具有丰富的功能和扩展性。与 Atom 编辑器类似，VS Code 也采用了 Web 技术来实现其用户界面和功能。

在技术层面上，VS Code 使用了 Electron 框架作为其基础。Electron 提供了让开发者使用 Web 技术构建跨平台桌面应用的能力，结合了 Chromium 渲染引擎和 Node.js 运行时环境。通过 Electron，VS Code 可以将 Web 技术与本地系统的功能进行整合，实现了高性能的代码编辑器体验。

Electron 的跨平台特性使得 VS Code 可以在多个操作系统（如 Windows、macOS 和 Linux）上运行，并提供一致的用户体验。同时，Electron 生态系统中丰富的插件和扩展库也为 VS Code 提供了丰富的功能和定制选项，使其成为开发者们喜爱的编辑器之一。

因此，可以说 VS Code 是基于 Electron 框架构建的，它充分利用了 Electron 的能力来提供跨平台支持和丰富的扩展性。

**问：sublime text 也是electron框架吗**

答：不，Sublime Text并不是基于Electron框架的应用程序。Sublime Text是一款由Sublime HQ开发的文本编辑器，它是使用C++编写的，而不是基于Electron。 Sublime Text在性能和响应速度方面非常出色，并且具有丰富的功能和插件生态系统，使其成为开发人员喜爱的工具之一。

Electron框架主要用于构建跨平台的桌面应用程序，并使用Web技术（HTML、CSS和JavaScript）作为应用程序的开发语言。相比之下，Sublime Text是一款传统的本地应用程序，使用原生的C++代码进行开发，没有使用Electron框架。

需要注意的是，虽然Sublime Text不是基于Electron开发的，但它支持丰富的插件系统和主题定制，使开发者可以根据自己的需要进行扩展和定制，以满足不同的开发需求。

片段五

**问：chrome 和Chromium区别**

答：Chrome和Chromium是两个与Web浏览器相关的项目，它们之间有以下区别：

1. **开发者和品牌所有权**：Chromium是由Google主导的开源项目，旨在开发一个基于开放标准的、高性能的Web浏览器。Chrome则是由Google基于Chromium开发的商业化产品，它在Chromium基础上进行了定制和增强，并添加了一些专有功能和服务。

2. **许可协议**：Chromium是根据开源许可证（如BSD许可证）进行发布的，这意味着任何人都可以查看和修改其源代码。Chrome则是一个闭源的商业产品，其源代码不对外开放。

3. **自动更新和附加功能**：Chrome具有自动更新功能，可以在后台自动升级到最新版本。此外，Chrome还包含一些Google专有的功能和服务，如自动同步书签和设置、Google账户集成、Chrome Web Store等。而Chromium没有这些Google专有的功能和服务，它更加注重提供一个基本的浏览器框架，允许用户和开发者根据自己的需求进行定制和扩展。

4. **稳定性和兼容性**：由于Chrome经过了Google的定制和测试，它在稳定性和兼容性方面可能会更加可靠。Chromium的开发者版本可能会包含一些实验性的功能和未经充分测试的代码，因此在稳定性和兼容性方面可能会存在一些问题。

总结来说，Chromium是一个由Google主导的开源项目，旨在开发一个高性能的、基于开放标准的Web浏览器。而Chrome则是基于Chromium开发的商业化产品，它在Chromium基础上进行了定制和增强，并添加了一些专有功能和服务。Chromium更加注重提供一个基本的浏览器框架，允许用户和开发者根据自己的需求进行定制和扩展，而Chrome则提供了更完整的功能和服务，并具有更高的稳定性和兼容性。

## 23/11/30
片段一

**问：什么是串口**

答：串口（Serial Port）是一种用于计算机与外部设备之间进行串行通信的接口。串口是一种传输数据的标准接口，它使用一对数据线（发送线和接收线）将数据以逐位的方式传输。串口通信常用于连接计算机与调制解调器、打印机、传感器等外部设备。

串口通信的特点是数据逐位传输，相对于并行通信（Parallel Port）而言，串口只使用几根数据线，节省了硬件资源。串口通信的速度相对较慢，通常用于低速数据传输或与外部设备进行简单的控制交互。

常见的串口类型包括RS-232、RS-422和RS-485等。其中，RS-232是最常见的串口标准，用于连接计算机与外部设备。RS-422和RS-485是用于远距离通信或多点通信的串口标准，适用于连接多个设备。

在计算机中，串口通常通过串口接口（Serial Port Interface）进行连接。计算机上的串口接口通常是一个DB-9或DB-25的连接口，用于插入串口线。然后，通过串口线将计算机与外部设备进行连接，实现数据的收发和控制命令的传输。

片段二

**问：default与缺省的区别是什么**

答：“Default”和”缺省”是两个不同的概念，尽管它们有时被用于类似的上下文。

“Default”通常是指系统或程序预先设置的默认值或行为。例如，在某些编程语言中，可以使用”默认参数”来定义函数参数的默认值，这意味着如果函数调用时没有提供参数，则将使用预定义的默认值。类似地，有些系统可能会有默认的设置或行为，如果没有用户自定义，则将使用默认值或行为。

另一方面，”缺省”通常是指某种状态或结果缺少某种组成部分或信息。例如，在计算机网络中，如果某个系统无法接收到预期的消息，则可能会使用”缺省”来表示缺失的消息，以便其他系统知道该系统未收到该消息。

因此，虽然这两个概念有时可以互换使用，但它们通常指的是不同的概念。”Default”通常指程序或系统的默认设置或行为，而”缺省”则通常指缺少某种信息或组成部分的状态或结果。

## 23/12/3
片段一

**问：NAT 模式下的 WSL 不支持 localhost 代理。什么意思**

答：这个问题涉及到网络地址转换（NAT）模式下使用 Windows Subsystem for Linux（WSL）时的一个限制。NAT 是网络中常见的一种模式，用于在私有网络和公共网络之间转换 IP 地址。在这种模式下，设备位于私有网络中，而路由器或网关用于将其通信路由到公共网络。这有助于隐藏私有网络中的具体设备。

根据你提供的信息，“NAT 模式下的 WSL 不支持 localhost 代理”意味着在使用 NAT 模式配置网络时，WSL 不支持通过 localhost 进行代理。这可能会影响你尝试在本地主机上运行的应用程序，尤其是涉及到通过 localhost 进行通信的情况。

片段二

**问：为什么.sh文件内开头要写#！/bin/bash**

答：在一个脚本文件（例如以 .sh 为扩展名的Shell脚本）的开头写上 #!/bin/bash 是为了告诉操作系统应该使用哪个解释器来执行这个脚本。

这一行被称为 "shebang" 或 "hashbang"，它告诉系统在执行这个脚本时要使用指定的解释器。在这个例子中，#!/bin/bash 意味着使用 Bash 解释器来执行这个脚本。

这是一个例子的解释：

#!: 这是 shebang 的符号，告诉系统下面是要使用的解释器。
/bin/bash: 这是 Bash 解释器的路径。在大多数系统上，Bash 被安装在 /bin/bash。这告诉系统去找到 Bash 并使用它来执行脚本。
有一些重要的事项要注意：

文件权限： 在使用 shebang 时，确保脚本文件有执行权限。你可以使用 chmod +x script.sh 命令为脚本添加执行权限。

指定其他解释器： 除了 Bash，你也可以使用其他 Shell 解释器，如 /bin/sh、/bin/zsh 等。取决于你的需求和系统上可用的解释器。

空格问题： 在 #! 后面和解释器路径之间不能有空格，这是 shebang 行的语法规则。

总的来说，shebang 行是一种通用的方式，使脚本文件在不同系统上能够正确执行，而不依赖于默认的 Shell 解释器。

## 3/5
**1.全新Ubuntu安装显卡驱动**

推荐法一：

`settings`-`about`-`software updates`-`addtional drivers`-切换到最新的`Using NVIDIA driver metapackage`

法二：

更新驱动 `sudo ubuntu-drivers autoinstall`

法三：

官网下载驱动安装 [视频教程](https://www.bilibili.com/video/BV1wY411p7mU?p=6&vd_source=890879be0041154ef8107bc3fadcc7c4)

下载官网驱动安装
`sudo ./NVIDIA-Linux-x86_64-550.54.14.run -no-x-check`

卸载官网驱动
`sudo ./NVIDIA-Linux-x86_64-550.54.14.run -uninstall`

清理残留文件
`sudo apt --purge remove nvidia*`
`sudo apt autoremove`


## 3/9
**1.空白本地配置`git clone`**

法一：SSH

```shell
$ ssh-keygen
$ cat ~/.ssh/id_rsa.pub
```
复制公钥，添加到 `https://github.com/settings/ssh/new` 后`git clone`选择SSH即可

法二：HTTPS

`https://github.com/settings/tokens` 生成 personal access token 并及时保存

`git clone` 选择HTTPS方式要求输入用户名及 personal access token

为了避免每次拉取重复输入密码，`git config --global credential.helper store` 后输入用户名及 personal access token 会被保存，以后无需密码

还要全局修改邮箱 `git config --global user.email "yuyao.jiang22@gmail.com"` 和用户名 `git config --global user.name "yuy4o"`。本地（当前仓库）修改无需加 `--global` 

修改后 `~/.gitconfig` 如下
```
[user]
	email = yuyao.jiang22@gmail.com
	name = yuy4o
[credential]
	helper = store
```

**2.写盘工具** [视频教程](https://www.bilibili.com/video/BV1o2421M7eA/?spm_id_from=333.1007.tianma.5-4-18.click&vd_source=890879be0041154ef8107bc3fadcc7c4)

法一：重装系统，可写入[微PE](https://www.wepe.com.cn/download.html)和多个镜像：[ventoy](https://www.ventoy.net/en/download.html)

法二：可修复电脑：[rufus](https://rufus.ie/en/)


**3.ubuntu20.04安装Linux原生微信** [参考链接1](https://blog.csdn.net/ccsodefhy/article/details/123193936) [参考链接2](https://forum.ubuntu.org.cn/viewtopic.php?f=73&t=492866) [下载链接](https://www.ubuntukylin.com/applications/106-cn.html)

**4.无公网IP时如何SSH远程连接Ubuntu系统** [视频](https://www.bilibili.com/video/BV1xe411y7kb/) [文档](https://www.bilibili.com/read/cv28469783/)

按照5中安装内网穿透工具 cpolar，端口 9200，登陆邮箱`15345180091@163.com`，获得ssh对应的公网地址比如`tcp://5.tcp.vip.cpolar.cn:10713`

在其他终端上，输入`ssh <ubuntu用户名>@5.tcp.vip.cpolar.cn -p 10713`，输入对应密码即可连接

## 3/10

**1.cd bin; ls 和cd bin && ls区别**

使用分号 (;) 分隔的两个命令会按照顺序执行，不考虑第一个命令的执行结果

使用逻辑与 (&&) 连接的两个命令只有在第一个命令成功执行的情况下才会执行第二个命令

**2.Ubuntu中对源码 ./configure, make, make install 安装包** [文档](https://blog.csdn.net/qq_29928745/article/details/107641995)

```shell
$ wget https://npm.taobao.org/mirrors/node/v12.16.1/node-v12.16.1.tar.gz
$ tar -zxvf node-v12.16.1.tar.gz
# 指定目录
$ ./configure --prefix=/usr/local/nodejs
# 使用4个进程
$ make -j 4 && make install
```
**3.make 和 make install 区别**

`make -j 4`：根据 `Makefile` 文件编译源代码，生成目标文件、静态库文件、可执行文件等，但这些文件通常位于构建目录中，而不是系统的标准库或可执行文件目录（如 /usr/local/bin 或 /usr/local/lib）

`make install`：将编译生成的库或可执行文件复制到系统路径下，可被其他程序或用户直接调用

## 3/12
**1.linux系统下怎么安装.deb文件？**

```shell
# deb是ubuntu 、debian格式。.deb是solaris系统下的安装包后缀名，安装如下
$ dpkg -i <xxx.deb>

# rpm是redhat 、fedora 、suse格式。对于red hat linux，安装如下
$ rpm -ivh <xxx.rpm>
```

## 3/26
**1.【GitHub】Branches 和 Tags的作用**:

Branches（分支）和 Tags（标签）是用于版本控制和代码管理的重要工具。分支用于支持并行开发，而标签则用于标记特定版本和发布。分支可以用来创建一个新的开发分支，允许在不影响主分支的情况下对代码进行修改和实验。通过分支，可以允许不同的开发者在同一个代码库中独立地开发和测试代码，而不会干扰彼此的工作。每个分支都有自己的代码提交历史和版本控制记录，可以随时合并到主分支中。标签则用于标记代码库中的一个特定版本。与分支不同，标签是一个静态的版本，不可修改。通过给代码库中某一版本打标签，可以方便地在未来查找、回溯和使用该版本代码。标签通常用于版本发布，比如在发布软件的时候，可以给某一版本打上标签，作为该软件的版本号

[Git根据指定分支、标签、提交哈希来克隆仓库](https://geek-docs.com/git/git-questions/1145_git_git_clone_particular_version_of_remote_repository.html)

**2.[【GitHub】Tags 和 Release 的区别？](https://blog.csdn.net/weixin_42600398/article/details/113527932)**:

Tags 是特定提交的一个指针，每个tag对应一个特定的commit

Release是具有changelogs和二进制文件的一级对象，它可以代表超出Git架构本身的一个特定时间点之前的所有项目历史。也就是通过release，不但能够通过源码体现出项目历史，还能通过已经编译好的二进制文件来进一步描述此时的项目状态。“超出Git架构本身"的意思则在于，git本身只能记录项目修改，本质上不适合将编译好的项目二进制文件记录下来。而通过release则把项目二进制文件保存了下来，方便用户下载，也方便查找特定版本的二进制文件。

标签是git中的概念，而release则是Github、码云等源码托管商所提供的更高层的概念。git本身是没有release这个概念的，只有tag。release基于tag，为tag添加更丰富的信息，一般是编译好的文件。

Release是源码托管商对git的tag功能的增强。通过git提供的tag功能，我们可以给项目进行版本标识，以识别特定的版本，如vo.1.0、v1.0.0等。而通过源码托管商提供的release功能，在tag的基础上我们可以添加编译好的二进制文件

**3.如何给WSL 2扩容硬盘（即扩展虚拟大小）？**: [中文版](https://blog.csdn.net/qq_15969343/article/details/129119789)	[英文版](https://learn.microsoft.com/zh-cn/windows/wsl/disk-space) 

## 3/27
**1.全新ubuntu配置ssh方法**: [参考链接](https://blog.csdn.net/weixin_43718675/article/details/106844150)

```shell
# 0.查看系统信息
$ uname -a
$ cat /etc/lsb-release

# 1.修改root密码并切换到root
$ sudo passwd root
$ su root

# 2.卸载重装
$ apt-get update
$ apt-get remove openssh-server
$ apt-get install openssh-server

# 3.编辑sshd_config
vim /etc/ssh/sshd_config
Port 22
PermitRootLogin yes
PasswordAuthentication yes

# 4.重启服务，检查状态
$ service ssh --full-restart
$ service ssh status

# 5.ifconfig后查看etho下的inet，形如172.27.26.118
$ sudo apt install net-tools
$ ifconfig
```

在同一局域网下的其他终端上通过`ssh root@172.27.26.118 -p 22`（端口号默认22可使用`ssh root@172.27.26.118`）进行SSH连接。第3步中默认的`PermitRootLogin prohibit-password`如果不改成`PermitRootLogin yes`，那么只能以普通用户如`ssh yuy4o@172.27.26.118`登录，无法以超级管理员root登录。


**2.拉取远程仓库的更新**: [参考链接](https://docs.github.com/zh/get-started/using-git/getting-changes-from-a-remote-repository)

`REMOTE-NAME` 默认是 `origin`，`BRANCH-NAME` 默认是 `master` 或 `main`。本地分支是 `master`，远程分支是 `origin/master`（可用 `git remote -v` 查看）

法一：`git fetch` + `git merge`
```shell
$ git fetch REMOTE-NAME
$ git merge REMOTE-NAME/BRANCH-NAME
```

法二：`git pull`，建议 `git pull` 前先切换到特定分支，再提交本地变化到远程。碰到合并冲突或希望回退到起始分支，`git merge --abort`
```shell
$ git pull REMOTE-NAME BRANCH-NAME
```

## 3/31 {#img}

![git](https://raw.githubusercontent.com/yuy4o/yuy4o/main/figures/240327git.jpg)

**1. [在本地新建分支并推送到远程分支](https://blog.csdn.net/ljj_9/article/details/79386306)**

`git checkout -b BRANCH-NAME` 在本地新建并切换到分支

`git branch -a` 查看本地和远程的分支状态，`remotes/origin/HEAD -> origin/main` 指远程的 `HEAD` 指针指向远程的 `main` 分支

`git push REMOTE-NAME LOCAL-BRANCH-NAME:REMOTE-BRANCH-NAME` 比如常见的 `git push origin main:main` 将本地分支推送到远程分支

删除远程 `main` 分支可以 1）将本地空分支推送到想删除的远程分支 `git push origin :main` 或 2）`git push origin --delete main`

`git checkout main` 先从想删除的分支换到其他分支如 `main`，再 `git branch -d BRANCH-NAME` 删除本地分支，`-d` 可删除和远程同步的本地分支，`-D` 可删除未推送到远程的本地分支

**2. [`git reset` 在本地分支撤销提交并选择是否还原工作目录中的文件](https://git-scm.com/docs/git-reset/zh_HANS-CN)**

`git reset HEAD~1` 或 `git reset COMMIT-HASH`

`HEAD~1`等于`HEAD^`表示最近一次提交，类似最近两次提交是`HEAD~2`。`--soft` 指不删除工作区代码改动，不撤销 `git add`，撤销`git commit`；默认参数 `--mixed` 指不删除工作区代码改动，撤销 `git add`，撤销`git commit`；`--hard` 指删除工作区代码改动，撤销 `git add`，撤销`git commit`

`git revert` 生成一次新的提交记录，`git reset` 将HEAD指针指到指定提交，不会生成放弃的提交记录

[Git提交错了不用慌，这三招帮你修改记录](https://developer.huawei.com/consumer/cn/forum/topic/0201454010956490762)

**3. 撤销远程分支的提交**

先用 2 方法在本地分支撤销提交，再用 `git push -f REMOTE-NAME BRANCH-NAME` 将本地分支强行推送并覆盖指定的远程分支。此处不用 `-f` 强推会失败，因为删除本地提交后导致本地分支和远程分支不一致（本地分支落后远程分支），会要求用 `git pull` 拉取远程提交到本地，这与要删除这个提交矛盾，因此必须强推来覆盖远程分支

**4. 其他流程中的撤销操作**

`git rm --cached` 将文件从暂存区（git索引）移除即该文件不再被跟踪，文件仍保留在工作区即本地文件系统中，用于 `git status` 检测到文件改动后 `git add FILE-NAME` 前

`git restore --staged FILE-NAME` 在 `git add FILE-NAME` 后，将添加到[图中](#img) `Repository` 中的文件内容撤回到工作区 `main tree`，即取消暂存区的文件更改，还原成未暂存的状态

**5. 在本地修改 `git commit` 注释**

`git commit --amend` 进入vi模式，修改注释后 `git push -f REMOTE-NAME BRANCH-NAME` 执行强推，理由同2，即解决远程分支和本地分支不一致的问题

**6. 指定分支上 `git log` 和 `git reflog` 的区别**

先 `git checkout BRANCH-NAME`，再 `git log` 查看特定分支的提交记录，提交信息和哈希值；`git reflog` 查看引用（如 `HEAD` 和分支）的移动历史，可以用于恢复或查找历史操作

**7. [合并分支间的提交—— 直接合并：将 `dev` 分支的开发内容合并到 `main`分支](https://git-scm.com/docs/git-merge/zh_HANS-CN)**

`git merge --no-ff dev` 在 `main` 上合并 `dev` 后，`main` 上会新增 `dev` 的所有提交和一个合并操作的节点 [1.Git分支-分支的新建与合并](https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%9A%84%E6%96%B0%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6#_basic_merging)	[2.阮一峰-Git分支管理策略](https://www.ruanyifeng.com/blog/2012/07/git.html)	[3.Git合并时--no-ff的作用](https://blog.csdn.net/zombres/article/details/82179122)

`--ff` 默认参数。可能的话，以快进方式解决合并问题（只更新分支指针以匹配合并后的分支；不创建合并提交）。当不可能时（当合并的历史不是当前历史的后代），创建一个合并提交；

`--no-ff` 在所有情况下都创建一个合并提交，即使该合并可以作为一个快进解决；

`--ff-only` 在可能的情况下，以快进的方式解决合并的问题。当不可能时，拒绝合并并以非零状态退出。快进式合并要求两个分支是线性的，如 8中 `dev` 变基到 `main` 后进行的 `git merge tmp` 为快进式合并

![mergenoff](https://raw.githubusercontent.com/yuy4o/yuy4o/main/figures/240327mergenoff.png)

**8. 合并`dev`上的提交到`main`—— 变基合并 & `cherry-pick`**

合并单个提交：`git checkout main` 检出到 `main`，`git cheery-pick COMMIT-HASH` 根据哈希合并提交到`main` [阮一峰-git cherry-pick 教程](https://www.ruanyifeng.com/blog/2020/04/git-cherry-pick.html)

合并多个相连的提交：`git checkout -b tmp COMMIT-HASH` 新建并切换到 `tmp` 分支， `COMMIT-HASH` 为`dev`上想合并的最后提交的哈希。`git rebase main` 将 `tmp` 变基到 `main`上。`git checkout main` 检出到 `main`，`git merge tmp` 合并 `tmp` 到 `main`。[1.Git分支-变基](https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA) [2.使用git rebase和merge合并特定commits到master分支](https://blog.csdn.net/weixin_44410537/article/details/104287338)

![rebase](https://raw.githubusercontent.com/yuy4o/yuy4o/main/figures/240327rebase.png)

[git-rebase](https://git-scm.com/docs/git-rebase/zh_HANS-CN)

变基合并和 `cherry-pick` 区别在于：变基合并后两个分支共享相同的提交，相同的提交哈希。`cherry-pick` 是将某次提交在分支间复制，两分支上提交的哈希不同，这样在 `main` 分支上的信息不能和原始开发的 `dev` 分支上保持一致。个人偏好变基合并的方式

【遗留问题】如图，`dev` 在 `main` 之前3次提交，已采用快进式合并将两分支变基合并成线性结构，如何将 `94d9` 和 `5bc1` 合并到 `main`，跳过 `3963` ？不要使用 `cherry-pick`。

![question](https://raw.githubusercontent.com/yuy4o/yuy4o/main/figures/240327question.png)

**9. `git stash` 保存和恢复进度**

`git status` 查看当前工作区中的改动，`git stash save COMMENT` 保存暂存区和工作区的改动；`git stash list` 查看每次保存的内容；`git stash apply @{x}` 恢复进度`@{x}`后不删除 `list` 记录；`git stash pop @{x}` 恢复进度`@{x}`后删除 `list` 记录；`git stash clear` 清空 `list` 记录

**10. `git worktree` 的作用**

`git worktree` 可以将分支切换到其他文件夹下

[1.git worktree是什么及其使用场景](https://www.cnblogs.com/skura23/p/8654248.html)	[2.使用Git Worktree并行开发测试](https://zhuanlan.zhihu.com/p/92906230)

**11. `git submodule` 在仓库中创建子模块-通过URL链接到公开仓库**

`git submodule add URL PATH` 在 `PATH` 下链接 `URL` 下的仓库，如[本仓库](https://github.com/yuy4o/yuy4o.github.io/tree/main/assets)下的 `lib @ 7bc0d86`

[1.Git工具- 子模块](https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%AD%90%E6%A8%A1%E5%9D%97)	[2.Git submodule 子模块的管理和使用](https://www.jianshu.com/p/9000cd49822c) [3.git-submodule](https://git-scm.com/docs/git-submodule/zh_HANS-CN)

## 4/8
**1. `markdown`内如何添加链接到某个标题**

[锚点](https://github.com/guodongxiaren/README?tab=readme-ov-file#%E9%94%9A%E7%82%B9)，[锚点用法](https://www.jianshu.com/p/6571d37c8060)

**2. 创建 `GitHub Pages` 站点的2种方式以及利用`GitHub Pages`站点展示`html`文件**

在仓库的 `settings` 内选择 `Pages` [创建站点](https://docs.github.com/zh/pages/getting-started-with-github-pages/creating-a-github-pages-site#creating-your-site)，如第3点所说：需要为站点创建入口文件。 `GitHub Pages` 将查找 `index.html`、`index.md` 或 `README.md` 文件，作为站点的入口文件。入口文件可放在 `root` 或 `docs` 路径下，之后选择 `Deploy from a branch`，等待一小会仓库自动部署网页，网址为 `https://<username>.github.io/<reponame>/`。以上**利用仓库的某个分支部署**是部署站点的第一种方式，第二种方式是自己编写 `.github\workflows`中的 `.yml` 配置文件，利用 `GitHub Actions` 进行动态部署

在用第一种方式静态部署好 `GitHub Pages` 后，假设 `<relativepath>` 是 `html` 文件在仓库中的相对路径，可访问 `https://<username>.github.io/<reponame>/<relativepath>` 在网页上查看 `html` 文件。即使仓库是私有的，依然能访问 `https://<username>.github.io/<reponame>` 和 `https://<username>.github.io/<reponame>/<relativepath>`    [github 项目预览html文件](https://blog.csdn.net/enter89/article/details/96481002)

`GitHub Pages`站点不仅可以展示`html`，`md` `pdf` `png` `gif`都可通过加上对应路径在网页上显示

## 4/9
**1. [GitHub 如何在网页上创建或重命名文件夹](https://blog.csdn.net/The_Time_Runner/article/details/97518582)**

1.点开文件具体路径下的 `编辑`，输入目标文件夹名 `folder1`，在其后输入 `/` 会直接创建文件夹。`folder1/folder2/file.md` 可继续输入文件夹名 `folder2` 及文件名 `file.md`

2.对于 `folder1/folder2/file.md`，输入 `../file2.txt` 可将 `file2.txt` 直接放入 `folder2` 文件夹

**2. GitHub 私有仓库里的文件安全吗**

[别再往git仓库中放敏感信息了,不安全!](https://z.itpub.net/article/detail/4010AE42DBEEC4FA421E84BD4BC3F50F)，建议使用[git-crypt](https://github.com/AGWA/git-crypt)

## 4/11
**1. Ubuntu 快捷键**

[Useful keyboard shortcuts](https://help.ubuntu.com/stable/ubuntu-help/shell-keyboard-shortcuts.html.en)

* Super key: Opens Activities search  (Windows key!)
* Ctrl+Alt+T: Ubuntu terminal shortcut
* Super+L or Ctrl+Alt+L: Locks the screen
* Super+D or Ctrl+Alt+D: Show desktop
* Super+A: Shows the application menu
* Super+Tab or Alt+Tab: Switch between running applications
* Super+Arrow keys: Snap windows
* Super+M: Toggle notification tray
* Super+Space: Change input keyboard (for multilingual setup)
* Alt+F2: Run console
* Ctrl+Q: Close an application window
* Ctrl+Alt+arrow: Move between workspaces
* Ctrl+Alt+Del: Log out
* Suspend Ubuntu system (Sleep): Super key(Windows key) + typing "suspend"  
Suspend mode in short: 
* suspend Command – Use systemd to suspend/hibernate from command line on Linux.
* pm-suspend Command – During suspend most devices are shutdown, and system state is saved in RAM.

**2. Ubuntu 知识积累**

apt 推荐的包：

`sudo apt install screenfetch/tree/htop`

[内置命令](https://blog.csdn.net/qq_36365520/article/details/109309916)：

查看内存 `free -h`

解压 `.tar.gz` 文件：
```shell
tar -zxvf .tar.gz
gzip -d .tar.gz
```

**3. windows 快捷键**

* win + r: run
* alt/cmd + r: 展示帧率、cpu/gpu利用率
* alt/cmd + z: 游戏内截屏/录屏
* alt/cmd + enter: 游戏全屏/窗口
* alt/cmd + tab: 多窗口切换

**4. windows 新装机时跳过联网**

```shell
shift F10

OOBE\BYPASSNRO
```
## 4/12

**1. 显卡详解**

Central/Graphic/Tensor Processing Unit

核心型号：显卡的档次看的就是核心，毫不夸张的说，不管显存或其它参数差别如何巨大，核心差了一档，性能就差了一档，再强的显存也补不回来。去百度搜索显卡天梯图，只要能记住尽可能多的型号，就能非常方便的判断显卡的高低

制作工艺Technology：如8纳米。工艺越先进，功耗就越低，单位芯片面积下能容纳的晶体管就更多，就能做出越高规格的产品。通常来讲，越新的型号制造工艺就越先进

核心频率GPU Clock：如1320MHZ等，频率越高，相同核心下性能就越强

流处理器数量：比如48个、96个、216个、800个等等，数量越多，性能越强。不过，N卡和A卡架构不同，相同性能的两个核心，A卡的流处理器数量是N卡的4-5倍，所以两家不能比较流处理器数量。

显卡核心中物理存在的晶体管数量Transistors

画质->显存大小：1K->6G，2K->8G，4k->12G

显存不足：画面延迟，帧数受限

integrated graphics是核显（集成显卡），dedicated graphics是独立显卡（独显）

集成显卡/板载显卡:集成在主板的北桥芯片里的显卡，使用内存 -> 图像处理和传输经过主板 -> 速度慢，性能差

2006 AMD收购ATI，提出cpu,gpu融合概念。2010 Intel 第一个核心显卡：整合gpu的cpu -> 使用内存和cpu算力 ->能效比高

显存频率：数据在显存上存取的速度，显存的工作频率

核显频率：GPU核心的频率

RTX3060 带宽360GB/s 位宽192bit

3090 显存位宽384bit

A100 显存位宽5120bit

显存位宽：显存在一个时钟周期能传输数据的位数，单位Bit

显存位宽越大，瞬间传输的数据量越大   常见128/192/256/384 Bit 

显存带宽：显示芯片和显存间数据传输速率 单位GB/s

显存带宽 = 显存频率 x 显存位宽 / 8bit

显存容量是蓄水池容量，显存频率是进水管流速，显存位宽是进水管的内径，显存带宽是进水管内的水量

位宽越大，制造难度就越大，成本也就越高，很多时候厂商选择低位宽与高频率的组合，这样在保证性能的同时还能降低成本（常见于新架构产品中）

CUDA核心数=流处理器单元=Shaders

显存类型：GDDR5之前都是单通道读写设计，GDDR6(X)双通道读写设计----对比内存的DDR

NVIDIA主要有三个系列的显卡：GeForce,Quadro,Tesla。

GeForce面向游戏，Quadro面向3D设计、专业图像和CAD等，Tesla面向科学计算。

GeForce面向游戏，性能高，但精度低，稳定性比Telsa差很多。毕竟玩游戏的时候如果程序崩了也就丢个存档，但服务器崩了没准挂掉一个公司。


帧数:单位时间内帧的生成数量

帧率:单位时间内显示的帧数 Frames per second

---
英特尔悄悄的在国内市场发布了 i5-13490F 处理器，国内市场独享，型号命名很奇怪。
从型号来看，定位介于酷睿i5-13500 和 i5-13400F 之间，这款处理器据说瞄准的是非X版锐龙 Ryzen 5 / 7 。

没有核显，不支持超频，核心/线程规格和13400F很像，同样也是6P+4E核心组合。但是缓存又比13400F高4MB，而且睿频也高0.2GHz。
这颗 i5-13490F 更像是在13400F基础上强化而来，拉升主频和加大缓存，但核心数量、线程仍没有达到 i5-13500 ，所以命名很奇怪，就像缝合怪。

另外，没有核显，需要配独显，所以更适合纯游戏玩家，搭 RTX 4070 Ti 更适合。

---

**2. ubuntu安装openfoam**

[openfoam.com](https://www.openfoam.com/) / [openfoam.org](https://openfoam.org/)

更新
```
sudo apt-get install ca-certificates 
sudo apt-get update
```

安装 `apt-add-repository`

add-apt-repository is not a package, so you just can't install it using sudo apt-get install add-apt-repository. This is wrong!
The package which contain add-apt-repository command is (and was all the time):
```
apt-get install software-properties-common
```
not python-software-properties as you may think. You can check this using the following command:
```
dpkg -S add-apt-repository
```
from [Unable to locate package add-apt-repository error [closed]](https://askubuntu.com/questions/445536/unable-to-locate-package-add-apt-repository-error)

添加许可链接
```
curl -s https://dl.openfoam.com/add-debian-repo.sh | sudo bash // sudo sh -c "wget -O - https://dl.openfoam.org/gpg.key > /etc/apt/trusted.gpg.d/openfoam.asc"
sudo add-apt-repository https://dl.openfoam.com/repos/deb/    // sudo add-apt-repository https://dl.openfoam.org/ubuntu
```
安装
```
sudo apt-get install openfoam2212-default   // sudo apt-get -y install openfoam11
```
移除
```
sudo apt-get autoremove openfoam2212-default
```

**2. ubuntu 配置 gcc**

配置
```
sudo gedit /etc/apt/sources.list
deb https://mirrors.aliyun.com/ubuntu/ xenial main
deb https://mirrors.aliyun.com/ubuntu/ xenial universe
```
安装
```
sudo apt-get update
sudo apt-get install g++-5 gcc-5
sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-5 100
sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-5 100
```
查看版本
```
ls /usr/bin/gcc*
ls /usr/bin/g++*
```
切换版本
```
sudo update-alternatives --config gcc
sudo update-alternatives --config g++
```

## 4/13

**1. 系统解释器**

这是你系统上安装的默认Python解释器。它可能是Python 2.x或Python 3.x的任何版本，取决于你的操作系统和配置。使用系统解释器是最简单的方法，但在项目之间共享可能存在版本和依赖问题。、

Virtualenv（虚拟环境）：

Virtualenv 是一个用于创建独立Python环境的工具。它允许你在一个项目中隔离不同的Python包和依赖，从而避免版本冲突。你可以创建一个虚拟环境，为每个项目指定特定的Python版本和依赖，这有助于项目的隔离和管理。

Conda环境：

Conda 是一个用于数据科学和机器学习的包管理和环境管理工具。它可以管理Python包，以及其他非Python软件包，并创建独立的环境。Conda可以用于创建Python环境，也可以用于管理其他语言的环境。它特别适合于科学计算和数据分析任务。

Pipenv环境：

Pipenv 是一个结合了pip（Python包管理工具）和虚拟环境的工具，用于创建和管理项目环境。它简化了依赖管理和环境配置的过程，提供了更简洁的 Pipfile 和 Pipfile.lock 文件来跟踪项目的依赖。

Poetry环境：

Poetry 是一个现代的Python包和依赖管理工具，它专注于项目的可维护性和一致性。Poetry不仅可以创建和管理虚拟环境，还可以生成依赖关系文件、构建和发布包，以及执行其他项目管理任务

**2. 关于Python 类的小demo**

```python
class Man:
    def __init__(self, name, age):
        # 从变量name -> 实例变量self.name
        self.name = name
        self.age = age
        print("initialized")

    def hello(self):
        return self.name, self.age, 'nice'

man = Man("Harry", 20)
print(man.hello())
```

## 4/14

**1. 注册国外信用卡**

推荐平台 [Fomepay](https://gpt.fomepay.com/#/)开卡，[教程一](https://blog.fanjunyang.zone/archives/card-foreign), [教程二](https://zhpengfei.com/best-virtual-credit-card-fomepay-for-chatgpt-plus/), [教程三](https://blog.csdn.net/2301_77543828/article/details/136699955), [教程四](https://dashen.wang/7358.html)

[购买OpenAI API：官网直连和中转加速，两种方案对比](https://chatgpt123.com/buy-openai-api)

**2. OpenAI 的 API keys**

[可使用的模型及限制](https://platform.openai.com/account/limits)

[api调用不同任务的方式](https://platform.openai.com/docs/api-reference)

[OpenAI 中文文档](https://openai.xiniushu.com/)

## 4/15

**1. 应用 Transformers 包 AutoTokenizer 向量化**

```python
from transformers import AutoTokenizer

tokenizer = AutoTokenizer.from_pretrained("mistralai/Mistral-7B-Instruct-v0.2")

messages = [
    {"role": "user", "content": "What is your favourite condiment?"},
    {"role": "assistant", "content": "Well, I'm quite partial to a good squeeze of fresh lemon juice. It adds just the right amount of zesty flavour to whatever I'm cooking up in the kitchen!"},
    {"role": "user", "content": "Do you have mayonnaise recipes?"}
]

tokenizer.apply_chat_template(messages, tokenize=False)
# <s>[INST] What is your favourite condiment? [/INST]Well, I'm quite partial to a good squeeze of fresh lemon juice. It adds just the right amount of zesty flavour to whatever I'm cooking up in the kitchen!</s>[INST] Do you have mayonnaise recipes? [/INST]

tokenizer.apply_chat_template(messages, return_tensors="pt")
# tensor([[    1,   733, 16289, 28793,  1824,   349,   574, 16020,  2076,  2487,
#          28804,   733, 28748, 16289, 28793,  6824, 28725,   315, 28742, 28719,
#           3448, 10473,   298,   264,  1179, 11322, 19961,   302,  6138, 23598,
#          18342, 28723,   661, 13633,   776,   272,  1103,  3558,   302,   686,
#          16944, 15637,   423,   298,  5681,   315, 28742, 28719, 13198,   582,
#            297,   272,  6132, 28808,     2,   733, 16289, 28793,  2378,   368,
#            506,   993,  7136,   864, 21116, 28804,   733, 28748, 16289, 28793]])
```
**2. C++ 中值的引用**
```cpp
// 将s中的字符全转为小写
class Solution{
public:
    std::string toLowerCase(std::string s){
        //for循环使用char&引用取出字符串元素,可直接在循环体内修改元素值,修改会被保存到字符串s本身
        //若用值拷贝char取出元素,则循环内的修改不会影响到s,返回的是原字符串
        for (char& it : s){
            it = tolower(it); //toupper()
        }
        return s;
    }
};
```
**3. 常见 cpu**
* xinye desktop

  i5-10400 2.9GHz 6核12线程
  
  UHD Graphics 630
  
  GeForce GT 730 2G
* xinye laptop

  i7-8550U 1.8GHz 4核8线程
  
  UHD Graphics 620
  
  RX 540 Series 2G
* self desktop

  i5-13490F 2.5GHz 10核16线程
  
  GeForce RTX 3060
* self laptop
  
  i5-8300H 2.3GHz 4核8线程
  
  UHD Graphics 630
  
  GeForce GTX 1050 2G
* gaming desktop

  i7-10700F 2.9GHz
  
  GeForce RTX 3060
* DELL Vostro 15 5501

  i7-1065G7 1.3GHz
  
  Iris(R) Plus Graphics
  
  GeForce MX330 2G

**4. 23年暑期实习记录**

查看GPU信息 nvidia-smi

验证有无GPU python -> import paddle -> paddle.utils.run_check() / paddle.device.get_device()

指定CPU/GPU python -> import paddle -> paddle.device.get_device('cpu') / paddle.device.get_device('gpu:0')

`tar -czvf file.tar.gz file` 压缩

`tar -xzvf file.tar.gz -C /path/to/destination` 解压缩

-c 表示创建新的压缩文件。
-x 表示解压缩（提取）.tar 文件中的内容。
-z 表示使用 gzip 压缩（仅针对 tar 命令）。
-v 显示详细信息，可以看到解压的过程和文件列表。
-f 后面跟着要解压的文件名，必须放在选项的最后。
-j 表示使用 bzip2 压缩（仅针对 tar 命令）。
-r 表示递归地压缩整个文件夹。

环境：
CUDA 11.2
ubuntu 18.04

PADDLENLP

python                    3.8.17

paddlenlp                 2.5.2

paddlepaddle              2.4.2

paddlepaddle-gpu          2.3.2 （高版本会出问题

paddleslim==2.4.1

carl

跑PaddleNLP/applications/text_classification，要在/root/miniconda3/envs/x/lib/python3.8/site-packages/paddle路径下增加_legacy_C_ops.py [来源](https://github.com/zhoutianzi666/Paddle/blob/f386777fe448f656bb6512964df07b074ab63003/python/paddle/_legacy_C_ops.py)

```python
# _legacy_C_ops.py
from paddle.fluid import core

from .fluid import framework

__all__ = []

_already_switch_to_eager_ = False

if not framework._in_eager_mode_:
    for name in dir(core.ops):
        globals()[name] = getattr(core.ops, name)
        __all__.append(name)
    _already_switch_to_eager_ = False
else:
    for name in dir(core.eager.ops.legacy):
        globals()[name] = getattr(core.eager.ops.legacy, name)
        __all__.append(name)
    _already_switch_to_eager_ = True


def switch_to_core_ops():
    global _already_switch_to_eager_
    if _already_switch_to_eager_:
        for name in dir(core.eager.ops.legacy):
            del globals()[name]
            __all__.remove(name)
        for name in dir(core.ops):
            globals()[name] = getattr(core.ops, name)
            __all__.append(name)
        _already_switch_to_eager_ = False


def switch_to_eager_ops():
    global _already_switch_to_eager_
    if not _already_switch_to_eager_:
        for name in dir(core.ops):
            del globals()[name]
            __all__.remove(name)
        for name in dir(core.eager.ops.legacy):
            globals()[name] = getattr(core.eager.ops.legacy, name)
            __all__.append(name)
        _already_switch_to_eager_ = True
```


MODULESCOPE

python  3.7.16

cryptography==39.0.1

tensorflow-gpu==1.15.0

torch==1.11.0

torchvision==0.12.0

torchaudio==0.11.0

pip install "modelscope[nlp]" -f https://modelscope.oss-cn-beijing.aliyuncs.com/releases/repo.html

翻墙时pip install非常慢，-i加国内镜像地址，使用国内的镜像源安装很快。

清华源：https://pypi.tuna.tsinghua.edu.cn/simple/

阿里云：http://mirrors.aliyun.com/pypi/simple/

中国科技大学：https://pypi.mirrors.ustc.edu.cn/simple/

豆瓣：http://pypi.douban.com/simple/

清华大学： https://pypi.tuna.tsinghua.edu.cn/simple/

中国科学技术大学： https://pypi.mirrors.ustc.edu.cn/simple/

## 4/16
**1. 查看c++ 当前版本**
```cpp
int main() {
    // 注意：__cplusplus 开头是连续两个下划线
    if (__cplusplus > 201703L) std::cout << "C++2a\n";
    else if (__cplusplus == 201703L) std::cout << "C++17\n";
    else if (__cplusplus == 201402L) std::cout << "C++14\n";
    else if (__cplusplus == 201103L) std::cout << "C++11\n";
    else if (__cplusplus == 199711L) std::cout << "C++98\n";
    else std::cout << "pre-standard C++\n";
}
```

**2. c++ 中的类**

1.静态成员不能直接访问非静态成员，可以把非静态变量作为参数传给静态函数

非静态成员函数可以访问静态成员变量并调用静态成员函数，也能访问非静态成员变量

2.静态成员和类实例无关，没有实例，属于整个类，被所有类的实例共享，用类名和作用域解析运算符::来访问静态成员变量不用this访问；

非静态成员属于类的实例，和实例相关，通过类的实例来调用->或.，不直接使用类名

3.this指针是一个隐式参数，它指向当前对象实例的地址，成员函数中可省略this->前缀，直接使用成员变量名来引用当前对象的成员变量。

当你在类的成员函数内部使用成员变量或调用成员函数时，编译器会自动添加this指针来引用当前对象的成员变量/函数

使用this->可以提高代码的可读性，特别是当成员变量与函数参数或局部变量同名时，区分成员变量和局部变量

4.将类的成员函数设置为静态有以下几种情况：

与类的实例无关的功能：如果一个函数不需要访问或修改类的实例的成员变量，也不需要调用其他非静态成员函数，那么可以将该函数设置为静态成员函数。静态成员函数在调用时不需要类的实例，可以直接通过类名和作用域解析运算符进行调用。

共享数据：静态成员函数可以访问类的静态成员变量，因此适合用于操作或处理与类的实例无关的共享数据。静态成员变量在所有类的实例之间共享相同的值，静态成员函数可以对这些共享数据进行操作。

工具函数或辅助函数：静态成员函数可以用于定义工具函数或辅助函数，这些函数提供与类的实例无关的功能，并且不需要访问类的非静态成员。

需要注意的是，静态成员函数没有隐式的 this 指针，因为它们与类的实例无关。在静态成员函数内部，不能直接访问非静态成员变量或非静态成员函数，因为它们是与类的实例相关的

将类的成员函数设置为静态的取决于函数是否与类的实例相关以及是否需要访问类的非静态

**3. 并行计算 对比 分布式计算**

并行计算，相对于**串行计算**而言，一般可分为时间并行和空间并行。时间并行可以看做是流水线操作，类似CPU执行的流水线，而空间并行则是目前大多数研究的问题，例如一台机器拥有多个处理器，在多个CPU上执行计算，例如MPI技术，通常可分为数据并行和任务并行。

分布式计算则是相对**单机计算**而言的，利用多台机器，通过网络连接和消息传递协调完成计算。把需要进行大量计算的工程数据分区成小块，由多台计算机分别计算，再上传运算结果后，将结果统一合并得出最终结果。

问：**并行计算和分布式计算区别**

答：并行计算和分布式计算是两种不同的计算模式。

并行计算是指在一台计算机内部，利用多个处理器或核心同时处理同一任务，以提高计算速度。在并行计算中，多个处理器或核心共享计算资源和内存，并通过高速的内部通信网络进行通信和协调。

分布式计算是指将一个大型计算任务分成许多小任务，并分配给多个计算机或服务器处理，以加快计算速度。在分布式计算中，多个计算机或服务器互相独立，通过网络通信进行协调和数据交换。

两种计算模式的主要区别在于计算资源和内存的共享方式，以及通信和协调方式。并行计算适用于单台计算机内部的高性能计算，而分布式计算则适用于涉及到多台计算机或服务器的大规模计算任务。

问：**用多台机器作为多个node，在node间用MPI通信是分布式计算吧？**

答：是的，使用多台机器作为多个节点，在节点之间使用MPI通信可以被认为是分布式计算。在分布式计算中，计算任务被分割成小的子任务并分配给不同的计算节点进行处理，节点之间通过网络进行通信和协调。MPI是一种常用的用于实现分布式内存并行计算的通信库。

问：**HPC也属于分布式计算吗？**

答：高性能计算（High Performance Computing，HPC）通常也被视为分布式计算的一种形式，因为它涉及将计算资源分布在多个计算节点上，并使用网络进行通信。但是，HPC更注重高性能计算节点的硬件和软件优化，以实现高性能和大规模计算，而不仅仅是分布式资源的连接和通信。因此，HPC和传统分布式计算有一些不同之处。

问：**在一台笔记本上单个CPU的不同core之间进行MPI通信，属于并行计算吧？**

答：是的，如果在一台笔记本上单个CPU的不同core之间进行MPI通信，这被认为是并行计算。并行计算是指同时使用多个处理器或CPU核心来执行单个任务或问题，以加快计算速度。在这种情况下，所有核心都属于同一台计算机，但它们可以在同一时间并行运行，以便更快地完成任务

问：**MPI通信既可以用于并行计算也可以分布式计算吗**

答：是的，MPI通信既可以用于并行计算，也可以用于分布式计算。在并行计算中，MPI通常用于在单个计算机的多个处理器核心之间进行通信，而在分布式计算中，MPI通常用于在不同的计算机节点之间进行通信。无论是并行计算还是分布式计算，MPI都提供了一种方便的方法来实现进程间的通信和同步。

## 4/18
**1. 在远程仓库重命名分支名后本地如何同步**

The default branch has been renamed! master is now named main

If you have a local clone, you can update it by running the following commands.
```shell
git branch -m master main
git fetch origin
git branch -u origin/main main
git remote set-head origin -a
```

## 4/19
**1. alpaca vicuna 和 llama 关系**

[大模型入门（一）—— LLaMa/Alpaca/Vicuna](https://www.cnblogs.com/jiangxinyang/p/17310398.html)

**[2. 对于昨天开源的llama3 技术学习](https://i.ifeng.com/c/8YtxXYou3gw)**

1.Llama 3 在模型架构上选择了相对标准的纯解码器 Transformer 架构。与 Llama 2 相比，Llama 3 进行了几项关键的改进：

使用具有 128K token 词汇表的 tokenizer，可以更有效地编码语言，从而显著提升模型性能

在 8B 和 70B 模型中都采用分组查询注意力 （GQA），以提高 Llama 3 模型的推理效率

在 8192 个 token 的序列上训练模型，使用掩码来确保自注意力不会跨越文档边界。

2.训练数据的数量和质量是推动下一阶段大模型能力涌现的关键因素。

从一开始，Meta Llama 3 就致力于成为最强大的模型。Meta 在预训练数据上投入了大量的资金。 据悉，Llama 3 使用从公开来源收集的超过 15T 的 token，是 Llama 2 使用数据集的七倍，其中包含的代码数据则是 Llama 2 的四倍。

为了确保 Llama 3 接受最高质量的数据训练，Meta 研究团队甚至提前使用启发式过滤器、NSFW 筛选器、语义重复数据删除方法和文本分类器来预测数据质量。

值得注意的是，研究团队还发现前几代 Llama 模型在识别高质量数据方面出奇地好，于是让 Llama 2 为 Llama 3 提供支持的文本质量分类器生成训练数据，真正实现了「AI 训练 AI」。

3.除了训练的质量，Llama 3 在训练效率方面也取得了质的飞跃。

Meta 透露，为了训练最大的 Llama 3 模型，他们结合了数据并行化、模型并行化和管道并行化三种类型的并行化。

在 16K GPU 上同时进行训练时，每个 GPU 可实现超过 400 TFLOPS 的计算利用率。研究团队在两个定制的 24K GPU 集群上执行了训练运行。

为了最大限度地延长 GPU 的正常运行时间，研究团队开发了一种先进的新训练堆栈，可以自动执行错误检测、处理和维护。此外，Meta 还极大地改进了硬件可靠性和静默数据损坏检测机制，并且开发了新的可扩展存储系统，以减少检查点和回滚的开销。

这些改进使得总体有效训练时间超过 95%，也让 Llama 3 的训练效率比前代足足提高了约 3 倍。

## 4/20
**[1. 什么是结构化数据？非结构化数据？半结构化数据？](https://www.zhihu.com/question/50986354/answer/276099917)**

**结构化数据**可以通过固有键值获取相应信息，且数据的格式固定，如RDBMS data

**半结构化数据**可以通过灵活的键值调整获取相应信息，且数据的格式不固定，如json，同一键值下存储的信息可能是数值型的，可能是文本型的，也可能是字典或者列表

**非结构化数据**不可以通过键值获取相应信息


**2. `gh-pages` 及 [下载文件方式](https://cloud.tencent.com/developer/ask/sof/116619615)**

对于带`.git`的仓库在切换分支时，文件资源管理器里的文件会根据不同分支对应变换，终端、文件资源管理器、vscode里的文件目录都是同步一致的

无论哪个分支部署的网页，即使是私有仓库，也能部署。问题是私有仓库的话，只能展示页面但无法链接到仓库里的私有文件。

任何仓库（公开或私有）都只能部署一个网页，可以选择某个分支（`main` 或 `gh-pages` 或其他分支，三者效果完全一样）的某个路径（仅可选路径`/(root)`或`/docs`）作为网页，网址为 `https://<username>.github.io/<repo-name>/`

通过网址获取**私有仓库**文件的方式，**公开**或**私有仓库**都适用：

> 如果知道文件在仓库内的相对路径如 `<repo-name>/figures/foo.png`，可访问 `https://<username>.github.io/<repo-name>/figures/foo.png` 查看，这种方式可直接在浏览器呈现 `png` 或 `pdf` 等内容而避免下载到本地

其他通过网址获取仓库文件的方式，仅限**公开仓库**：

> 1.在浏览器上查看 `https://github.com/<username>/<repo-name>/blob/<branch-name>/figures/foo.png` 

> 2.直接下载到本地 `https://raw.githubusercontent.com/<username>/<repo-name>/<branch-name>/figures/foo.png` 等效于 `https://github.com/<username>/<repo-name>/blob/<branch-name>/figures/foo.png?raw=true`

两类方式的区别在于 将仓库部署成页面后，无论原仓库公开与否， `https://<username>.github.io/<repo-name>/` 都拥有访问仓库内所有文件（除了测试时`.gitignore`无法查看）的权限，前提知道文件的相对路径。而如果不**通过pages开放权限**，`https://github.com/<username>/<repo-name>/` 和 `https://raw.githubusercontent.com/<username>/<repo-name>/` 仅限公开仓库的文件访问

以上所说部署仅针对 `Deploy from a branch` 类型而非 `Github Actions`，用后者部署的私有仓库尝试通过相对路径展示文件时无果，故创建一个[公开仓库](https://yuy4o.github.io/yuy4o/)用于储存该[私有仓库](https://yuy4o.github.io)需要调用的文件

**3. Github 链接转换**

`https://github.com/<USER NAME>/<REPO NAME>/blob/main/<PATH TO FILE>` 网页链接转成可通过 `wget` 下载的纯文字链接：`https://raw.githubusercontent.com/<USER NAME>/<REPO NAME>/HEAD/<PATH TO FILE>`

[Github 上传图片文本后的公共链接](https://github.com/orgs/community/discussions/28316#discussioncomment-5967003)

**4. 编辑文档过程中 萌生写个vscode插件的想法**

功能：在`markdown`里链接大量文件，能够快速生成文件的路径。比如输入文件的相对路径是 `"..\foo of foo.pdf"`，`markdown`中输出为 `[foo of foo](../foo%20of%20foo.pdf)`

关键点：1.自动用`%20`替换路径中的空格，2.支持用户自定义是否将Windows下路径中的 `\` 改成 `/`，3.能够一键或自动检测当前文件中的超链接是否生效，4.能够自定义复制某段文字的遍数（可能已有）

## 4/21
**1. TCP/IP 协议的分层**

TCP/IP 协议分为4层：应用层、传输/运输层、网络层（IP地址和子网划分、静态路由和动态路由、网络层协议、NAT和MPLS、IPv6）、网络接口层（可细分为数据链路层、物理层）

## 4/23
**[1. 一个仓库的分支有部分提交，此时新建分支会基于已有分支的提交内容。如何新建一个空的分支？](https://stackoverflow.com/questions/34100048/create-empty-branch-on-github)**

```
git switch --orphan <new branch>
git commit --allow-empty -m "<commit message>"
git push -u origin <new branch>
```
**2. 克隆仓库时如何判断大小**

`Personal Settings - Repositories` 里显示的仓库大小是指 该仓库所有提交记录的大小，即克隆到本地后 `.git` 的大小，和上传到仓库内的文件大小无关

如果只需要最新一次的提交，可以 `git clone <link> --depth=1`，可以减少下载 `.git` 的大小。`.git`大小和提交次数无关，不同仓库的单次 `.git` 大小也无关，`.git`大小只取决于仓库本身的改动

## 5/10

**1. 长文本入门**

GPT-3.5的4000 token最多只能输入3000个英文单词或者2000个汉字

文本越长，越难聚集充分注意力，难以完整消化；注意力限制下，短文本无法完整解读复杂信息；处理长文本需要大量算力，提高成本.大部分模型都是基于Transformer结构。该结构中包含一项最重要的组件即自注意力机制，在该机制下，对话机器人就可以跨越用户输入信息顺序的限制，随意地去分析各信息间的关系。自注意力机制的计算量会随着上下文长度的增加呈平方级增长，比如上下文增加32倍时，计算量实际会增长1000倍

杨雨对光锥智能说，“目前主要有三种不同的解决方案，分别为借助模型外部工具辅助处理长文本，优化自注意力机制计算和利用模型优化的一般方法。”

**第一种解决方案的核心思路就是给大模型开“外挂”。** 主要方法是将长文本切分为多个短文本处理，模型在处理长文本时，会在数据库中对短文本进行检索，以此来获得多个短文本回答构成的长文本。每次只加载所需要的短文本片段，从而避开了模型无法一次读入整个长文本的问题。

**第二种解决方案是现在使用最多的方法，主要核心在于重新构建自注意力计算方式。** 比如LongLoRA技术的核心就在于将长文本划分成不同的组，在每个组里进行计算，而不用计算每个词之间的关系，以此来降低计算量，提高速度。

前两种模式也被杨植麟称之为“蜜蜂”模型，即通过对检索增强的生成或上下文的降采样，保留对部分输入的注意力机制，来实现长文本处理的效果。

据杨植麟介绍，在优化自注意力机制计算还存在一种方式，也被其称之为 “金鱼”模型。即通过滑动窗口等方式主动抛弃上文，以此来专注对用户最新输入信息的回答。这样做的优点显而易见，但是却无法跨文档、跨对话比较和总结分析。

**第三种解决方案是专注于对模型的优化。** 如LongLLaMA以OpenLLaMA-3B和OpenLLaMA-7B 模型为起点，在其基础上进行微调，产生了LONGLLAMAs新模型。该模型很容易外推到更长的序列，例如在8K token上训练的模型，可以很容易外推到256K窗口大小。

对模型的优化还有一种较为普遍的方式，就是通过通过减少参数量（例如减少到百亿参数）来提升上下文长度，这被杨植麟称之为 “蝌蚪”模型。这种方法会降低模型本身的能力，虽然能支持更长上下文，但是任务难度变大后就会出现问题。

长文本的“不可能三角”困境或许暂时还无解，但这也明确了大模型厂商在长文本的探索路径：在文本长短、注意力和算力三者之中做取舍，找到最佳的平衡点，既能够处理足够的信息，又能兼顾注意力计算与算力成本限制。

## 5/19

**1. 如何修改 `hosts` 来加速CDN**

查看当前网络IP地址 [网址1](https://www.ipaddress.com/) 或 [网址2](https://www.iplocation.net/)，输入 `https://sites.ipaddress.com/<web link>#ipinfo` 查看和域名 `web link` 对应的公网ip地址，可[修改 `host` 文件](https://zhuanlan.zhihu.com/p/520937015)手动绑定cdn和ip地址，利用[CDN加速](https://juejin.cn/post/6987688566520299528)

**2. Windows 修改 Github 的 DNS**

进入`C:\Windows\System32\drivers\etc`修改`hosts`，结尾增加
```
140.82.114.4 github.com
151.101.129.194 github.global.ssl.fastly.net
```

通过 `https://sites.ipaddress.com/github.com/#ipinfo` 查得 `140.82.114.4` 和 `140.82.112.3` 是 `github` 的公网地址，`https://sites.ipaddress.com/github.global.ssl.fastly.net/#ipinfo` 同样可查 `github.global.ssl.fastly.net` 的公网

**3. [Windows 修改 DNS](https://world.crisp.help/zh/article/dns-5a9iai/)**

[如何清除 DNS 缓存](https://cloud.tencent.com/developer/article/1523705)，[好用的DNS服务器推荐](https://blog.csdn.net/Myx74270512/article/details/130503691)

## 5/21

**1. git 无法检测到文件夹字母大小写的更改**

工作路径下运行 `git config core.ignorecase false` 关闭git忽略大小写的默认设定

## 5/27

**1. [conda安装虚拟环境时发生ClobberError](https://blog.csdn.net/wheat_straw/article/details/121380537)**

运行 `conda clean --all`，然后再运行安装命令

## 5/30

**1. conda导出环境包**

`conda env export --name <环境名称> > environment.yml`

**2. 获取 DataFrame的行的2种方法**

对于DataFrame 对象可以使用索引`iloc`(基于行的整数位置进行索引和切片)或切片`[]`(基于行标签、整数位置或布尔数组进行索引和切片)操作来获取DataFrame 中的行，如

```python
import pandas as pd
df = pandas.DataFrame([['a',1],['b',2]],columns=['name','age'])
df[:1]
#   name  age
# 0    a    1
df.iloc[:1]
#   name  age
# 0    a    1
```

**3. 运行命令时直接指定conda环境，避免环境的频繁切换**

`conda run -n <ENV NAME> python your_script.py`，任何环境下可直接运行

**4. 命令行中 `>` 和 `>>` 区别**

文件不存在，都会新建文件。`>` 会覆盖文件内容，`>>` 会在文末追加内容

**5. conda activate 和 source activate 的区别**

`conda activate` 是 Conda 4.4 的新特性，更加现代和标准，而 `source activate` 是 Conda 4.3以前的旧方式

## 6/4

**1. git 配置不同上传者的信息**

`C:\Users\Administrator\.gitconfig` 适用于全局，`<PROJECT PATH>\.git\config` 适用具体项目，后者优先。文件中增加以下字段

```
[user]
	email = <USER EMAIL>
	name = <USER NAME>
```

## 6/7

**1. `torch.__version__` 得到的输出 `2.3.0+cu121` 但是运行 `nvidia-smi` 输出是 `CUDA Version: 12.2` 这两个CUDA版本是不是矛盾了**

`2.3.0+cu121` 表示 PyTorch 安装包是用 CUDA 12.1 编译的，`CUDA Version: 12.2`表示安装的 NVIDIA 驱动程序支持 CUDA 12.2。CUDA 驱动程序通常是向后兼容的，CUDA 驱动程序（12.2）与 PyTorch 编译时使用的 CUDA 版本（12.1）不冲突

```python
!nvidia-smi && nvcc --version

import torch
print(f"PyTorch version: {torch.__version__}")
print(f"CUDA available: {torch.cuda.is_available()}")
print(f"CUDA version (from PyTorch): {torch.version.cuda}")
print(f"cuDNN version: {torch.backends.cudnn.version()}")
print(f"CUDA device name: {torch.cuda.get_device_name(0)}")
```

## 6/17

[in-context learning](https://blog.csdn.net/onlyyoujojo/article/details/135066078)：预训练的大模型不需要进行微调，只需要根据提示，也就是上下文（in-context），就能够完成特定的任务

## 6/19

**APT**

不只Ubuntu，其实Debian系统的系统（Debian，Ubuntu，Deepin，Raspbian等）都可以使用apt命令安装软件。在Ubuntu 16 之前要使用apt-get install 软件包来安装，在Ubuntu 16 之后可以直接使用apt install 软件包来安装。

apt 命令用法：

1. 更新软件列表：apt update -y

2. 搜索软件: apt search 关键字

3. 显示软件包详情：apt show 软件包名

4. 安装软件：apt install 软件包名

5. 升级指定软件：apt upgrade 软件包名

6. 升级所有可以升级的软件：apt upgrade

7. 卸载软件：apt remove 软件包名

8. 卸载软件并移除软件依赖：apt autoremove 软件包名

9. 卸载软件并删除配置文件：apt remove 软件包名 --purge

在终端占直接运行命令就可以安装，比如使用命令安装 gimp `sudo apt install gimp -y`

**SNAP**

snap是在Ubuntu 16 新添加的一种软件包格式。这种格式把软件运行所需的依赖全部打包到软件包里面， 运行的时候持载到一个虚拟的环境里面运行。所有这种格式的软件包安装时不会破坏系统现有的软件包依赖。

snap命令用法：

1. 搜索软件包：snap find 关键字

2. 显示软件包详情：snap info 软件包名

3. 安装软件包：snap install 软件包名

4. 升级指定软件：snap refresh 软件包名

5. 升级所有可以升级的软件：snap refresh

6. 卸载软件：snap remove 软件包名

也是直接在终端运行命令就可以安装，比如使用命令安装wps `sudo snap install wps-2019-snap`

**DPKG**

上面3种方法都只能安装已经添加的软件源里面的软件。但像网易云音乐、百度网盘这些并没有在软件源里面，而是在官网提供deb后缀的软件包下载，这种软件我们就要用到dpkg命令来安装了 `sudo dpkg -i 文件名.deb`

## 7/14

NAT（网络地址转换）和内网穿透是两种不同的网络技术，它们的目的和实现方式有所不同。

NAT是一种在IP数据包通过路由器或防火墙时重写来源IP地址或目的IP地址的技术。它主要用于在多台主机但只有一个公有IP地址的环境下，实现内网主机与外部网络的通信。NAT技术可以将内网主机的私有IP地址转换为公有IP地址，从而使得内网主机能够访问外部网络。

内网穿透是一种使特定源IP地址和源端口号的数据包不被NAT设备屏蔽而正确路由到内网主机的技术。它主要用于在具有NAT设备的网络中，实现内网主机与外部网络的通信。内网穿透技术可以使得公网IP能够正确路由到内网主机，从而使得外部网络能够访问内网主机的服务。

个人理解：
- 没有NAT，内网的主机访问不了外网，开了NAT，NAT将内网主机的私有IP转成公有IP，用公有IP才能访问外网

- 没有内网穿透，外网的主机访问不了内网，内网穿透将内网主机的私有IP转成公有IP，公有IP才能被外网主机访问

## 7/15

**1. json.dumps() 和 json.dump() 的区别**

```python
import json
data = {"name": "John", "age": 30}
json_string = json.dumps(data)
print(json_string)  # 输出: {"name": "John", "age": 30}
```
```python
import json
data = {"name": "John", "age": 30}
with open('data.json', 'w') as f:
    json.dump(data, f)
```
**2. 修改vllm框架推理代码来记录对话历史`history.log`和元数据`history.json`**

```python
# v0.5.1 vllm/entrypoints/openai/api_server.py
@app.post("/v1/chat/completions")
async def create_chat_completion(request: ChatCompletionRequest,
                                 raw_request: Request):
    generator = await openai_serving_chat.create_chat_completion(
        request, raw_request)
    print('************')
    print('request', request)
    print('raw request', raw_request)
    print('************')

    print('##############')
    print('Question:', request.messages[0]['content'])    
    print('Answer:', generator.choices[0].message.content)
    print('##############')
    
    # model_dump()生成的是dic 格式，单引号；model_dump_json()生成的是json 格式，双引号
    print(request.model_dump())
    print(generator.model_dump())

    print(request.model_dump_json())
    print(generator.model_dump_json())
    
    # async with aiofiles.open('/data/jiangyy/myvllm/history.json', 'a') as f:
    #     await f.write(f"{request.model_dump()}\n{generator.model_dump()}\n")
    
    async with aiofiles.open('/data/jiangyy/myvllm/history.json', 'a') as f:
        await f.write(f'{"request": {request.model_dump_json()},') # python中f字符串将单个{转义成双{
        await f.write(f'"response": {generator.model_dump_json()}},')
    
    # async with aiofiles.open('/data/jiangyy/myvllm/history2.json', 'a') as f:    
    #     await json.dump(request.model_dump_json(),f)
    #     await json.dump(generator.model_dump_json(),f)
    
    # 保存log,在异步函数中进行同步的 I/O 操作（如文件写入）可能会导致阻塞，从而引发异常。
    async with aiofiles.open('/data/jiangyy/myvllm/history.log', 'a') as f:
        await f.write(f"Question: {request.messages[0]['content']}\nAnswer: {generator.choices[0].message.content}\n")
        
    if isinstance(generator, ErrorResponse):
        return JSONResponse(content=generator.model_dump(),
                            status_code=generator.code)
    if request.stream:    
        return StreamingResponse(content=generator,
                                 media_type="text/event-stream")
    else:
        assert isinstance(generator, ChatCompletionResponse)
        return JSONResponse(content=generator.model_dump())
```
**3. 推理代码中`host`参数的地址选择**

host 参数是指你的应用程序监听的 IP 地址。具体来说：

- 0.0.0.0：表示你的应用程序会监听所有可用的网络接口。这意味着你的服务器将接受来自所有网络接口的连接请求。通常用于开发和测试，尤其是当你希望从任何网络接口进行访问时。
    
- localhost 或 127.0.0.1：表示你的应用程序只会接受来自本地机器的连接请求。这通常用于在本地开发环境中，确保只有本地系统可以连接到该服务器。

- 具体的 IP 地址（例如 172.27.33.66）：表示你的应用程序将监听该特定的网络接口，只接受发送到该 IP 地址的连接请求。这通常用于在生产环境中，当你有多个网络接口并且只希望从特定的接口进行连接时。

如果你的服务器的地址是 172.27.33.66，并且你希望应用程序只接受发送到该 IP 地址的连接请求，你应该将 host 参数设置为 172.27.33.66。如果你希望应用程序接受来自所有网络接口的连接请求，则可以将 host 设置为 0.0.0.0。

## 7/18

`pip list | grep gradio`， `ls | grep 1.0.0`：管道符号 `|` 将 `ls` 的输出作为 `grep gradio` 的输入，`grep` 是一个用于搜索文本的命令行工具。它从标准输入或文件中搜索满足特定模式的行，并将这些行输出

## 7/31

**1. Windows 本地和服务器之间利用 `scp` 传输文件**

服务器上 `ifconfig` 得到的IPv4 地址往往和 ssh 连接的IP地址不一致，表明这个 IP 地址可能不是服务器的直接网络接口，而可能是通过网络地址转换 (NAT) 或负载均衡器映射的

本地上传到远程：`scp -r <file_name> jiangyy@172.29.83.59:/data/jiangyy/`

远程下载到本地：`scp -r jiangyy@172.29.83.59:/data/jiangyy/<file_name> .`

以上命令都是在本地终端执行的，如果想在远程终端传到本地的 `<local_username>@<local_ip>`，因为本地ip和远程ip不在同一个内网中，本地能连通远程的映射后的ip，远程映射前的 ip 连接不了本地 ip
